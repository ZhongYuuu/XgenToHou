//**************************************************************************/
// Copyright 2015 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk
// license agreement provided at the time of installation or download,
// or which otherwise accompanies this software in either electronic
// or hard copy form.
//**************************************************************************/

#include "SSAO_Common.ogsfh"

#ifdef CLIPPING
    #include "ClippingGL.ogsfh"
#endif

//
// XGen wide spline NormalDepth pass shader
//

// Uniforms
//
uniform mat4  gWorld                 : world;
uniform mat4  gWorldInverse          : worldinverse;
uniform mat4  gWorldViewProjection   : worldviewprojection;
uniform vec3  gViewDirection         : viewdirection;
uniform vec3  gWorldCameraPosition   : worldcameraposition;
uniform float gDepthPriority         : depthpriority;
uniform bool  gIsOrthographic        : isorthographic;
uniform float gProjZSense            : ProjectionZSense;

// Varyings
//
attribute VS_INPUT
{
    vec3 Pos                : POSITION;
    vec3 mayaBitangentIn    : BINORMAL;
    vec2 uvCoord            : TEXCOORD0;
    vec2 wCoord             : TEXCOORD1;
    float xgenCVWidth       : TEXCOORD2;
}

attribute VS_TO_GS
{
    vec3 mayaTangentIn      : TANGENT;
    vec3 mayaBitangentIn    : BINORMAL;
    vec2 uvCoord            : TEXCOORD0;
    vec2 wCoord             : TEXCOORD1;
    float xgenCVWidth       : TEXCOORD2;
    vec4 NormalDepth        : TEXCOORD3;

}

attribute GS_TO_PS
{
    vec4 NormalDepth        : TEXCOORD3;
#ifdef CLIPPING
    vec4 oHPw               : TEXCOORD6;
#endif
}

attribute pixelOut2
{
    vec4 oMRT[2]            : COLOR0;
}

// Vertex Shader
//
GLSLShader VS_NormalDepth
{

vec3 ixgenFacingCameraVSToGSTw(vec3 Pm, vec3 Bw, mat4 worldInverse, vec3 viewDirection, vec3 worldCameraPosition, bool isOrthographic)
{
    // Get a view vector from camera to vertex
    vec3 viewVector = Pm - mul(worldInverse, vec4(worldCameraPosition, 1.0f)).xyz;

    // Orthographic camera is directional
    if (isOrthographic)
    {
        vec3 viewOrigin = mul(worldInverse, vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
        vec3 viewTarget = mul(worldInverse, vec4(viewDirection, 1.0f)).xyz;
        viewVector = viewTarget - viewOrigin;
    }

    // Tangent is the cross product of view vector and bitangent
    return normalize(cross(viewVector, Bw));
}

void main()
{
    vsOut.mayaTangentIn   = ixgenFacingCameraVSToGSTw(Pos, mayaBitangentIn, gWorldInverse, gViewDirection, gWorldCameraPosition, gIsOrthographic);
    vsOut.mayaBitangentIn = normalize(mayaBitangentIn);
    vsOut.uvCoord         = uvCoord;
    vsOut.wCoord          = wCoord;
    vsOut.xgenCVWidth     = xgenCVWidth;
    gl_Position           = vec4(Pos, 1.0f);

    vec3 norm             = normalize(cross(vsOut.mayaTangentIn, vsOut.mayaBitangentIn));
    vsOut.NormalDepth.xyz = mat3(gWVITXf[0].xyz, gWVITXf[1].xyz, gWVITXf[2].xyz) * norm;
    vsOut.NormalDepth.z   = gProjZSense * vsOut.NormalDepth.z;
    vsOut.NormalDepth.w   = 0.0f;  // Fill in GS
}

}

// Geometry Shader
//
GLSLShader GS_NormalDepth
{

layout (lines) in;
layout (triangle_strip, max_vertices = 4) out;

void main()
{
    // Early Out
    if( all(equal(gl_in[0].gl_Position.xyz, gl_in[1].gl_Position.xyz)) )
    {
        return;
    }

    vec3 pm;

    pm = gl_in[0].gl_Position.xyz - gsIn[0].mayaTangentIn * gsIn[0].xgenCVWidth * 0.5f;
    gl_Position = mul(gWorldViewProjection, vec4(pm, 1.0f));
    gl_Position.z -= gl_Position.w * 2.0f * gDepthPriority;
    gsOut.NormalDepth.xyz = gsIn[0].NormalDepth.xyz;
    gsOut.NormalDepth.w = gProjZSense * (gWVXf * vec4(pm, 1.0f)).z;
#ifdef CLIPPING
    gsOut.oHPw = gWXf * vec4(pm, 1.0f);
#endif
    EmitVertex();
    
    pm = gl_in[0].gl_Position.xyz + gsIn[0].mayaTangentIn * gsIn[0].xgenCVWidth * 0.5f;
    gl_Position = mul(gWorldViewProjection, vec4(pm, 1.0f));
    gl_Position.z -= gl_Position.w * 2.0f * gDepthPriority;
    gsOut.NormalDepth.xyz = gsIn[0].NormalDepth.xyz;
    gsOut.NormalDepth.w = gProjZSense * (gWVXf * vec4(pm, 1.0f)).z;
#ifdef CLIPPING
    gsOut.oHPw = gWXf * vec4(pm, 1.0f);
#endif
    EmitVertex();
    
    pm = gl_in[1].gl_Position.xyz - gsIn[1].mayaTangentIn * gsIn[1].xgenCVWidth * 0.5f;
    gl_Position = mul(gWorldViewProjection, vec4(pm, 1.0f));
    gl_Position.z -= gl_Position.w * 2.0f * gDepthPriority;
    gsOut.NormalDepth.xyz = gsIn[1].NormalDepth.xyz;
    gsOut.NormalDepth.w = gProjZSense * (gWVXf * vec4(pm, 1.0f)).z;
#ifdef CLIPPING
    gsOut.oHPw = gWXf * vec4(pm, 1.0f);
#endif
    EmitVertex();

    pm = gl_in[1].gl_Position.xyz + gsIn[1].mayaTangentIn * gsIn[1].xgenCVWidth * 0.5f;
    gl_Position = mul(gWorldViewProjection, vec4(pm, 1.0f));
    gl_Position.z -= gl_Position.w * 2.0f * gDepthPriority;
    gsOut.NormalDepth.xyz = gsIn[1].NormalDepth.xyz;
    gsOut.NormalDepth.w = gProjZSense * (gWVXf * vec4(pm, 1.0f)).z;
#ifdef CLIPPING
    gsOut.oHPw = gWXf * vec4(pm, 1.0f);
#endif
    EmitVertex();

    EndPrimitive();
}

}

// Pixel Shader
//
GLSLShader PS_NormalDepth
{

void main()
{
#ifdef CLIPPING
    int i;
    for ( i = 0; i < gNumClipPlanes; i++ ) {
        if (dot(psIn.oHPw, gClipPlanes[i]) < 0.0f) discard;
    }
#endif

    oMRT[0] = vec4((normalize(psIn.NormalDepth.xyz) + vec3(1.0f,1.0f,1.0f)) * 0.5f, 0.0f);
    oMRT[1] = vec4(psIn.NormalDepth.w,psIn.NormalDepth.w,psIn.NormalDepth.w,psIn.NormalDepth.w);
}

}

// Techniques
//
technique main
{
    pass pNormalDepth
    {
        VertexShader   (in VS_INPUT,      out VS_TO_GS vsOut) = VS_NormalDepth;
        GeometryShader (in VS_TO_GS gsIn, out GS_TO_PS gsOut) = GS_NormalDepth;
        PixelShader    (in GS_TO_PS psIn, out pixelOut2)      = PS_NormalDepth;
    }
}


