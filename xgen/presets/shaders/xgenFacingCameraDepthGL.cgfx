//**************************************************************************/
// Copyright 2015 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk
// license agreement provided at the time of installation or download,
// or which otherwise accompanies this software in either electronic
// or hard copy form.
//**************************************************************************/

//
// XGen wide spline Depth pass shader
//

// Uniforms
//
uniform float4x4 gWorld                 : world;
uniform float4x4 gWorldInverse          : worldinverse;
uniform float4x4 gWorldViewProjection   : worldviewprojection;
uniform float3   gViewDirection         : viewdirection;
uniform float3   gWorldCameraPosition   : worldcameraposition;
uniform float    gDepthPriority         : depthpriority;
uniform bool     gIsOrthographic        : isorthographic;

// Varyings
//
struct VS_INPUT
{
    float3 Pos              : POSITION;
    float3 mayaBitangentIn  : TEXCOORD7;
    float2 uvCoord          : TEXCOORD0;
    float2 wCoord           : TEXCOORD1;
    float xgenCVWidth       : TEXCOORD2;
};

struct VS_TO_GS
{
    float3 mayaTangentIn    : TEXCOORD6;
    float3 mayaBitangentIn  : TEXCOORD7;
    float2 uvCoord          : TEXCOORD0;
    float2 wCoord           : TEXCOORD1;
    float4 HPos             : POSITION;
    float xgenCVWidth       : TEXCOORD2;
};

struct GS_TO_PS
{
    float4 HPos             : POSITION;
};

// Vertex Shader
//
float3 ixgenFacingCameraVSToGSTw(float3 Pm, float3 Bw, float4x4 worldInverse, float3 viewDirection, float3 worldCameraPosition, bool isOrthographic)
{
    // Get a view vector from camera to vertex
    float3 viewVector = Pm - mul(worldInverse, float4(worldCameraPosition, 1.0f)).xyz;

    // Orthographic camera is directional
    if (isOrthographic)
    {
        float3 viewOrigin = mul(worldInverse, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
        float3 viewTarget = mul(worldInverse, float4(viewDirection, 1.0f)).xyz;
        viewVector = viewTarget - viewOrigin;
    }

    // Tangent is the cross product of view vector and bitangent
    return normalize(cross(viewVector, Bw));
}

VS_TO_GS VS_Depth(VS_INPUT vsIn)
{
    VS_TO_GS vsOut;

    vsOut.mayaTangentIn   = ixgenFacingCameraVSToGSTw(vsIn.Pos, vsIn.mayaBitangentIn, gWorldInverse, gViewDirection, gWorldCameraPosition, gIsOrthographic);
    vsOut.mayaBitangentIn = normalize(vsIn.mayaBitangentIn);
    vsOut.uvCoord         = vsIn.uvCoord;
    vsOut.wCoord          = vsIn.wCoord;
    vsOut.xgenCVWidth     = vsIn.xgenCVWidth;
    vsOut.HPos            = float4(vsIn.Pos, 1.0f);

    return vsOut;
}

// Geometry Shader
//
LINE TRIANGLE_OUT void GS_Depth(AttribArray<VS_TO_GS> gsIn)
{
    // Early Out
    if( all(gsIn[0].HPos.xyz == gsIn[1].HPos.xyz) )
    {
        return;
    }

    GS_TO_PS gsOut;
    float3 pm;

    pm = gsIn[0].HPos.xyz - gsIn[0].mayaTangentIn * gsIn[0].xgenCVWidth * 0.5f;
    gsOut.HPos = mul(gWorldViewProjection, float4(pm, 1.0f));
    gsOut.HPos.z -= gsOut.HPos.w * 2.0f * gDepthPriority;
    emitVertex(gsOut);

    pm = gsIn[0].HPos.xyz + gsIn[0].mayaTangentIn * gsIn[0].xgenCVWidth * 0.5f;
    gsOut.HPos = mul(gWorldViewProjection, float4(pm, 1.0f));
    gsOut.HPos.z -= gsOut.HPos.w * 2.0f * gDepthPriority;
    emitVertex(gsOut);

    pm = gsIn[1].HPos.xyz - gsIn[1].mayaTangentIn * gsIn[1].xgenCVWidth * 0.5f;
    gsOut.HPos = mul(gWorldViewProjection, float4(pm, 1.0f));
    gsOut.HPos.z -= gsOut.HPos.w * 2.0f * gDepthPriority;
    emitVertex(gsOut);

    pm = gsIn[1].HPos.xyz + gsIn[1].mayaTangentIn * gsIn[1].xgenCVWidth * 0.5f;
    gsOut.HPos = mul(gWorldViewProjection, float4(pm, 1.0f));
    gsOut.HPos.z -= gsOut.HPos.w * 2.0f * gDepthPriority;
    emitVertex(gsOut);

    restartStrip();
}

// Pixel Shader
//
float4 PS_Depth(GS_TO_PS psIn) : COLOR0
{
    return float4(0.0f, 0.0f, 0.0f, 0.0f);
}

// Techniques
//
technique main
{
    pass pDepth
    {
        VertexProgram   = compile glslv VS_Depth();
        GeometryProgram = compile glslg GS_Depth();
        FragmentProgram = compile glslf PS_Depth();
    }
}

