// ===========================================================================
// Copyright 2021 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/**
 * @file xgen.mel
 * @brief Contains the xgen MEL procedure.
 *
 * <b>CONFIDENTIAL INFORMATION: This software is the confidential and
 * proprietary information of Walt Disney Animation Studios ("WDAS").
 * This software may not be used, disclosed, reproduced or distributed
 * for any purpose without prior written authorization and license
 * from WDAS. Reproduction of any section of this software must include
 * this legend and all copyright notices.
 * Copyright Disney Enterprises, Inc. All rights reserved.</b>
 *
 * @author Ernie Petti
 * @author Thomas V Thompson II
 * @author Stephen D. Bowline
 * @author Ying Liu
 *
 * @version Created 05/17/02
 */

/** 
 * This procedure sets up 3d paint context presets for use with xgen
 */
proc xgenInit3dPaintCtx()
{
    string $regionMapCtx = "xgRegionMap3dPaintContext";
    if( !`art3dPaintCtx -exists $regionMapCtx` ) {

        // The following line saves the settings of the brush to a string,
        // so that they are remembered between Maya sessions. Unfortunately, 
        // restoring the "dragSlider" setting (i.e. calling art3dPaintCtx -e -dragSlider "none" )
        // changes the current mouse cursor icon momentarily. To avoid this, we will 
        // simply not remember brush settings inbetween sessions. see MAYA-27958.
        //rememberCtxSettings `art3dPaintCtx -i1 "art3dPaint.png" $regionMapCtx`;
        
        art3dPaintCtx -i1 "art3dPaint.png" $regionMapCtx;
        art3dPaintCtx -e  -opacity 1.0  -alphablendmode "Constant" -mappressure "Radius" $regionMapCtx;
        art3dPaintCtx -e  -fty 1024  -ftx 1024  -fsy 1024 -fsx 1024 $regionMapCtx;
    }
}

global proc xgenInitFilters() 
{
    if (`itemFilter -exists renderableObjectShapeFilter`)
    {
        itemFilter -e
                -byType "xgmNurbsPatch"
                -byType "xgmSubdPatch"
                -classification "builtIn"
                renderableObjectShapeFilter;

        //  Need to delete and recreate these guys as they have copies
        //  of the old filter.
        //
        if (`itemFilter -exists renderableObjectsAndSetsFilter`) {
            itemFilter -e -cls "user" renderableObjectsAndSetsFilter;
            delete renderableObjectsAndSetsFilter;
        }
        if (`itemFilter -exists lightLinkingObjectFilter`) {
            itemFilter -e -cls "user" lightLinkingObjectFilter;
            delete lightLinkingObjectFilter;
        }
        itemFilter 
                -union "renderableObjectShapeFilter" "renderableObjectSetFilter"
                -text (uiRes("m_xgen.kRenderableObj"))
                -category "Multilister"
                -classification "builtIn"
                renderableObjectsAndSetsFilter;

        itemFilter 
                -union "renderableObjectsAndSetsFilter" "DefaultShadingGroupsFilter"
                -classification "builtIn"
                lightLinkingObjectFilter;
    }
}


/**
 * This procedure does all the setup needed to load everything related to
 * xgen, including all the plug-ins, setting up menus and shelves, and
 * setting up all global variables and preferences.
 */
global proc xgen()
{
    global int $gXgmUseHandler = 0;

    // Bring in the XGen python api
    eval( "python( \"import xgenm as xg\" )" );
    eval( "python( \"import xgenm as xgen\" )" );
    eval( "python( \"import xgenm.xgGlobal as xgg\" )" );
    eval( "python( \"import xgenm.ui as xgui\" )" );
    eval( "python( \"import xgenm.ui.dialogs.xgExportPreset as xgpreset\" )" );
    eval( "python( \"import xgenm.ui.dialogs.xgIgCreateInteractiveDescription as xgCreateInteractiveDescription\" )" );
    eval( "python( \"import xgenm.ui.dialogs.xgSplineToGeometryConvert as xgSplineToGeometryConvert\" )" );
    
    // initialize xgen global info
    python("xgg.initXGen()");    

    // Import the xgen pipline stuff (if the SceneNavigator is present)
    // NOTE: the xgenHandler isn't imported by default with xgpipe, since
    // the user may not want to load xgen in some instances.  When running
    // in maya, we always import the handler, so that we can save/load xgen.
    global int $gDlUseSceneNavigator;
    if ( $gDlUseSceneNavigator ) {
        $gXgmUseHandler = 1;
        eval( "python( \"import xgenm.xgpipe\" )" );
        eval( "python( \"import xgenm.xgpipe.xgenHandler\" )" );
    }

    // Define and initialize XGen global variables here...
    // Note:  UI related vars should be declared in xgenUI.mel
    //
    global string $gXgmGuideAttrList[];
    if ( size( $gXgmGuideAttrList ) == 0 ) {
        $gXgmGuideAttrList = { "width", "taper", "blend" };
    }

    xgenInitFilters();

    // Source all of the xgen mel scripts to get any mpxCommands hooked
    // up properly. In general this isnt required, but in order to safely
    // reload a plugin you must either resource or always use eval() when
    // calling an mpxCommand. This is a bit safer.
    string $root = python("xg.rootDir()");
    string $folder = $root+"scripts/";
    string $scripts[] = `getFileList -folder $folder -filespec "*.mel"`;
    for ( $script in $scripts ) {
        if ( $script == "xgen.mel" ) continue;
        if ( $script == "xgenHUD.mel" ) continue;
        // ------------------
        // Check to see if its a .res.mel file. If so, do not source it
        // otherwise all strings in mel files will be localized to english
        // last and then stay that way, making it unable to be localized to 
        // other languages.
        if ( endsWith($script, ".res.mel") ) continue;
        // ----------------- 
        if ( catch(`eval( "source "+$script )`) ) {
            string $fmt = (uiRes("m_xgen.kCouldNotSource"));
            warning `format -s $script $fmt`;
        }
    }

    eval( "xgmRegisterRuntimeCmd" ); 
    
    // Setup any file related callbacks.
    eval( "muMessageAdd AfterNew xgmAfterNewCB" );
    eval( "muMessageAdd BeforeOpen xgmBeforeOpenCB" );    
    eval( "muMessageAdd AfterOpen xgmAfterOpenCB" );
    eval( "muMessageAdd BeforeSave xgmBeforeSaveCB" );
    eval( "muMessageAdd AfterSave xgmAfterSaveCB" );
    eval( "muMessageAdd BeforeImport xgmBeforeImportCB" );
    eval( "muMessageAdd AfterImport xgmAfterImportCB" );
    eval( "muMessageAdd BeforeCreateReference xgmBeforeCreateReferenceCB" );
    eval( "muMessageAdd AfterCreateReference xgmAfterCreateReferenceCB" );
    eval( "muMessageAdd BeforeLoadReference xgmBeforeLoadReferenceCB" );
    eval( "muMessageAdd AfterLoadReference xgmAfterLoadReferenceCB" );
    eval( "muMessageAdd MayaExiting xgmMayaExitingCB" );

    // Opening Maya starts a new scene, so get the initial expressions set.
    // evalDeferred( "xgmAddExpressions" );

    xgenInit3dPaintCtx();
}

global proc xgmExpressionEditor(){}
global proc xgmRegisterRuntimeCmd()
{

    if (!`runTimeCommand -exists XgCreateDescriptionEditor`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kOpenTheUIForTheXgenTools1"))
                -ann (uiRes("m_xgen.kOpenTheXGenWindowAnn1"))
                -image "xgDEditor.png"
                -category "Menu items.Modeling.Generate"
                -command  "python(\"xgui.createDescriptionEditor()\");"
                XgCreateDescriptionEditor;
    }

    if (!`runTimeCommand -exists XGenOpenLibraryWindow`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kOpenTheUIForTheXgenLibrary"))
                -ann (uiRes("m_xgen.kOpenTheXGenLibraryAnn1"))
                -image "xgLibrary.png"
                -category "Menu items.Modeling.Generate"
                -command  "XGenLibraryWindow"
                XGenOpenLibraryWindow;
    }

    if (!`runTimeCommand -exists XgCreateDescription`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kCreateDescription"))
                -ann (uiRes("m_xgen.kCreateDescriptionAnn"))
                -longAnnotation (uiRes("m_xgen.kCreateDescriptionLongAnn"))
                -image "xgCreateDescription.png"
                -category "Menu items.Modeling.Generate"
                -command  "python(\"if xgui.createDescription(): xgui.createDescriptionEditor()\");"
                XgCreateDescription;
    }

    if (!`runTimeCommand -exists XgImportCollections`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kImportMenuBar"))
                -ann (uiRes("m_xgen.kImportAnn"))
                -image "xgImportDescription.png"
                -category "Menu items.Modeling.Generate"
                -command  "python(\"xgui.importFile()\")" 
                XgImportCollections;
    }

    if (!`runTimeCommand -exists XgExportCollections`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kExportMenuBar"))
                -ann (uiRes("m_xgen.kExportAnn"))
                -category "Menu items.Modeling.Generate"
                -command  "python(\"xgui.exportFile()\")"
                XgExportCollections;
    }

    if (!`runTimeCommand -exists XgConvertInteractiveGroomToPoly`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kXgmSplineGeometryConvert"))
                -annotation (uiRes("m_xgen.kXgmSplineGeometryConvertAnnot"))
                -category "Menu items.Modeling.Generate"
                -command  ("python(\"import xgenm.xmaya.xgmSplineToGeometryConvert as convert;convert.convertPrimToPolygon(True)\")")
                XgConvertInteractiveGroomToPoly;
    }

    if (!`runTimeCommand -exists ToggleXGenDisplayHUD`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kXGenDisplayHUD"))
                -annotation (uiRes("m_xgen.kXGenDisplayHUDAnnot"))
                -category "Menu items.Modeling.Generate"
                -command  ("setXGenHUDVisibility(!`optionVar -q xgenHUDVisibility`);")
                ToggleXGenDisplayHUD;
    }

    if (!`runTimeCommand -exists XgPreview`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).preview(False)\");"
                XgPreview;
    }

    if (!`runTimeCommand -exists XgGuideTool`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmGuideContextSelect"
                XgGuideTool;
    }

    if (!`runTimeCommand -exists XgGroomingVis`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "igToggleVisibility"
                XgGroomingVis;
    }

    if (!`runTimeCommand -exists XgExpressionEditor`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmExpressionEditor"
                XgExpressionEditor;
    }

    if (!`runTimeCommand -exists XgExportArchive`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kExportSelectionAsArchive"))
                -ann (uiRes("m_xgen.kExportSelectionAnn"))
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).exportArchives()\");"
                XgExportArchive;
    }

    if (!`runTimeCommand -exists XgBatchExportArchive`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kBatchConvertScenesToArchives"))
                -ann (uiRes("m_xgen.kBatchConvertAnn2"))
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).batchExportArchives()\");"
                XgBatchExportArchive;
    }

    if (!`runTimeCommand -exists XgConvertToPolygon`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kConvertPrimitivesLabel"))
                -image "xgConvertToPoly.png"
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"import xgenm.xmaya.xgmConvertPrimToPolygon as cpp;cpp.convertPrimToPolygon(True)\")"
                XgConvertToPolygon;
    }

    if (!`runTimeCommand -exists XgConvertToInteractiveGroom`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kConvertToInteractiveGroomLabel"))
                -annotation (uiRes("m_xgen.kConvertToInteractiveGroomAnnot"))
                -image "xgConvertToIG.png"
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createXgIgConvertToInteractiveGroomWindow()\")"
                XgConvertToInteractiveGroom;
    }

    if (!`runTimeCommand -exists XgImportPreset`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kImportPresetLabel"))
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.importPreset()\")"
                XgImportPreset;
    }

    if (!`runTimeCommand -exists XgExportPreset`) {
        runTimeCommand -default true
                -label (uiRes("m_xgen.kExportPresetLabel"))
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.exportPreset()\")"
                XgExportPreset;
    }

    if (!`runTimeCommand -exists XgPreRendering`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmPreRendering"
                XgPreRendering;
    }

    // TTF Keywords
    string $kw_cards = (uiRes("m_xgen.kKw_cards"));
    string $kw_polygon_strips = (uiRes("m_xgen.kKw_polygon_strips"));
    string $kw_create_cards = (uiRes("m_xgen.kKw_create_cards"));
    string $kw_hair_count = (uiRes("m_xgen.kKw_hair_count"));
    string $kw_hair_details = (uiRes("m_xgen.kKw_hair_details"));
    string $kw_hair_info = (uiRes("m_xgen.kKw_hair_info"));
    string $kw_legacy_XGen_to_interactive_groom = (uiRes("m_xgen.kKw_legacy_XGen_to_interactive_groom"));
    string $kw_hair = (uiRes("m_xgen.kKw_hair"));
    string $kw_xgen = (uiRes("m_xgen.kKw_xgen"));

    // TTF Tags
    string $tag_Hair = (uiRes("m_xgen.kTag_Hair"));
    string $tag_Fur = (uiRes("m_xgen.kTag_Fur"));
    string $tag_Generate = (uiRes("m_xgen.kTag_Generate"));

    catchQuiet(`
        runTimeCommand -edit
            -tags       ($tag_Hair + ";" + $tag_Fur)
            -keywords   ($kw_cards + ";" + $kw_polygon_strips + ";" + $kw_create_cards)
            XgConvertInteractiveGroomToPoly
    `);
    catchQuiet(`
        runTimeCommand -edit
            -tags       ($tag_Hair + ";" + $tag_Fur)
            -keywords   ($kw_hair_count + ";" + $kw_hair_details + ";" + $kw_hair_info)
            ToggleXGenDisplayHUD
    `);
    catchQuiet(`
        runTimeCommand -edit
            -tags       ($tag_Hair + ";" + $tag_Fur)
            -keywords   ($kw_legacy_XGen_to_interactive_groom)
            XgConvertToInteractiveGroom
    `);
    catchQuiet(`
    runTimeCommand -edit
        -tags       ($tag_Fur + ";" + $tag_Generate + ";" + $tag_Hair)
        -keywords   ($kw_hair + ";" + $kw_xgen)
        XgCreateDescription
    `);
}

/**
 * Procedure to import the palettes that reside as maya objects but
 * have yet to be brought in as c-side objects. 
 */
proc xgmPostLoadImportPalettes( string $palettes[] )
{

    if( `about -batch` )
    {
        // initialize xgen global info
        python("xgg.initXGen()");
    }

    string $currentScene = `file -q -sceneName`;
    string $currentSceneName = `basenameEx $currentScene`;
        string $currentSceneDir = `dirname $currentScene`;

    print (uiRes("m_xgen.kImportingXgenCollections"));
    for ( $palette in $palettes ) {

        // Get the namespace from the palette
        string $ns = python("xg.objNameSpace(\""+$palette+"\")");
        
        // Determine if we will load work from palette or delta file
        int $importDelta = 0;
        if ( `attributeExists "xgExportAsDelta" $palette` ) {
            $importDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
            $importDelta = substituteAllString($importDelta, "\\", "\\\\");
        }

        // Get the file to import from. Can be a .xgen or .xgd file
        string $fileName = `getAttr ( $palette + ".xgFileName" )`;
    $fileName = substituteAllString($fileName, "\\", "\\\\");
        
        // The XG file may be loaded when a scene is imported or referenced
    // However, the directory of the imported/referenced file may be different
    // from the directory of the current scene. To make the current scene file
    // load the XG file like other files, we need to copy the XG file into 
    // the directory of the current scene file and rename it following the
    // naming rule.
    // For example, if we reference "//dir1/file1" to "//dir2/scene" the new XG
    // file should be "//dir2/scene_file1_collections.xgen"
    global string $gXgenSourceFile;
    string $sourceFileDir = `dirname $gXgenSourceFile`;
    if( $gXgenSourceFile != "" )
    {
        string $basePaletteName = python("xg.stripNameSpace(\""+$palette+"\")");
        string $copyCmd = "xg.copyFileToNewDir(\"" + $fileName          + "\", \"" 
                                                    + $currentSceneName + "\", \"" 
                                                    + $sourceFileDir    + "\", \"" 
                                                    + $currentSceneDir  + "\", \"" 
                                                    + $basePaletteName  + "\", \"" 
                                                    + $ns               + "\")";
        $fileName = python($copyCmd);
    }
    // If source file is empty, it means we are loading the file
    // no need to copy the file
    else
    {
        $notfound = !`filetest -r $fileName`;
        if( $notfound == 1 && $currentSceneDir != "" ){
            $fileName = $currentSceneDir + "/" + $fileName;
        }
    }

        if ( $importDelta ) {
            // Import using a base palette, collection of previous deltas,
            // and a work in progress delta file.
            
            // Get the base palette to compare against
            string $baseFile = `getAttr ( $palette + ".xgBaseFile" )`;
            $baseFile = substituteAllString($baseFile, "\\", "\\\\");
            $notfound = !`filetest -r $baseFile`;
            if( $notfound == 1 ){
                string $tmp = $currentSceneDir + "/" + $baseFile;
                $baseFile = $tmp;
            }

            // Get the list of delta files to apply to the base 
            string $deltas = `getAttr ( $palette + ".xgDeltaFiles" )`;
            $deltas = substituteAllString($deltas, "\\", "\\\\");
            string $deltaFiles[] = stringToStringArray( $deltas, "," );
            for ( $i=0; $i<size($deltaFiles); $i++ ) {
                $notfound = !`filetest -r $deltaFiles[$i]`;
                if( $notfound == 1 ){
                    $deltaFiles[$i] = $currentSceneDir + "/" + $deltaFiles[$i];
                }
            }
            $deltas = stringArrayToString( $deltaFiles, "," );
            $deltas = xgmStringToStringList( $deltas, "," );

            // Import base palette while applying deltas and wrapping everything
            string $pal = python( "xg.importPalette(\"" + $baseFile + "\","+
                                  $deltas + ", \""+$ns+"\" )" );
            if ( $pal == "" ) continue;
            
            // Apply the latest delta
            if ( $fileName != "" ) {
                python( "xg.applyDelta(\"" + $palette + "\", \"" 
                                           + $fileName + "\")" );
            }

        } else {
            // Import the palette file and wrap everything except the guides.
            python("xg.importPalette(\""+$fileName+"\", [], "+
                                    "\""+$ns+"\" )");
        }
    }
    print (uiRes("m_xgen.kDoneImporting"));
}

proc string getPaletteFileName(string $baseSceneName, string $palette)
{
    string $ns = python("xg.objNameSpace(\""+$palette+"\")");
    string $paletteName = python("xg.stripNameSpace(\""+$palette+"\")");
    string $baseFilename = python("xg.buildFileName(\"" + $paletteName + "\", \"" +
                                    $baseSceneName + "\", \"" +
                                    $ns +"\")");
    
    return $baseFilename;
}

/**
 * Procedure to set the file name of the exported palettes.
 */
proc xgmSetPalettesFileName()
{
    string $palettes[];
    catchQuiet ( $palettes = python("xg.palettes()") );
    
    if ( !`size($palettes)` ) return;
    
    string $file = `file -q -sceneName`;
    string $baseSceneName = `basenameEx $file`;
    
    for ( $palette in $palettes ) {
        if( `objExists $palette` ) {
            int $exportDelta = 0;
            if ( `attributeExists "xgExportAsDelta" $palette` ) {
                $exportDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
            }

            string $orgXgFileName = `getAttr ( $palette + ".xgFileName" )`;
            string $orgXgBaseName = `getAttr ( $palette + ".xgBaseFile" )`;
            
            if ( $exportDelta ) {
                if ( strip($orgXgBaseName) == "" ) {
                    setAttr -type "string" ( $palette + ".xgBaseFile" ) $orgXgFileName;
                }
                if ( strip($orgXgFileName) == "" || !endsWith(strip($orgXgFileName), ".xgd") ) {
                    string $baseName = getPaletteFileName($baseSceneName, $palette);
                    $baseName += ".xgd";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $baseName;
                }
            }
            else {
                string $baseName;
                string $xgFileName;
                if ( strip($orgXgFileName) == "" ) {
                    $baseName = getPaletteFileName($baseSceneName, $palette);
                    $xgFileName = $baseName + ".xgen";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $xgFileName;
                }
                else {
                    $baseName = getPaletteFileName($baseSceneName, $palette);
                    $xgFileName = $baseName + ".xgen";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $xgFileName;
                }
                setAttr -type "string" ( $palette + ".xgBaseFile" ) "";
            }
        }
    }
}

/**
 * Procedure to export the palettes into separate files and save the
 * file location into an attribute on the palette.
 * Make sure to call xgmSetPalettesFileName() before call this method.
 */
proc xgmExportPalettes()
{
    string $file = `file -q -sceneName`;
    string $dir = `dirname $file`;
    $dir = python("xg.fixPath(\""+$dir+"\")");
    
    string $palettes[];
    clear $palettes;
    catchQuiet ( $palettes = python("xg.palettes()") );

    if ( !`size($palettes)` ) return;
    
    print (uiRes("m_xgen.kExportingXgenCollections"));
    for ( $palette in $palettes ) {
        if( `objExists $palette` ) {
            // Check if delta should be exported
            int $exportDelta = 0;
            if ( `attributeExists "xgExportAsDelta" $palette` ) {
                $exportDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
            }

            string $xgFileName = `getAttr ( $palette + ".xgFileName" )`;
            string $filename = $dir + "/" + $xgFileName;
            if ( $exportDelta ) {
                // Export the palette as delta diffed original snapshot
                
                int $result = python( "xg.createDelta(\"" + $palette +
                                      "\", \"" + $filename + "\")");
                if ( $result == -1 ) {
                    string $fmt = (uiRes("m_xgen.kDeltaError"));
                    error `format -s $palette $fmt`;
                } else if ( $result == 0 ) {
                    setAttr -type "string" ( $palette + ".xgFileName" ) "";
                }
            }
            else {
                python("xg.exportPalette(\""+$palette+"\",\""+$filename+"\")");
                
                // create a snapshot when first save the palette, then delta file can be created
                // if a snapshot exists, do nothing
                python("xg.initSnapshot(\""+$palette+"\")");
            }
        }
    }
    print (uiRes("m_xgen.kDoneExporting"));
}

proc updateMRShaderByGlobalMotionBlurSettings(string $shaderNode)
{
    if (!`objExists miDefaultOptions` || !`objExists mentalrayGlobals`)
        return;

    int $mb = `getAttr "miDefaultOptions.motionBlur"`;
    string $attr = $shaderNode + ".motion_blur";
    if ($mb > 0)
        setAttr $attr 1;
    else
        setAttr $attr 0;
    
    int $mb_steps = `getAttr "miDefaultOptions.motionSteps"`;
    $attr = $shaderNode + ".motion_blur_steps";
    setAttr $attr $mb_steps;

    // for "motion_blur_multiplier", always set it to 1 
    $attr = $shaderNode + ".motion_blur_multiplier";
    setAttr $attr 1;

    float $mb_offset = `getAttr "mentalrayGlobals.exportMotionOffset"`;
    $attr = $shaderNode + ".motion_blur_mode";
    if ( $mb_offset == 0.0 )
        setAttr $attr 0;
    else if ( $mb_offset == 0.5 )
        setAttr $attr 1;
    else
        setAttr $attr 2;
    
    // for "motion_blur_factor", always set it to 1 
    // as mayaMotionLength has been used when rendering
    $attr = $shaderNode + ".motion_blur_factor";
    setAttr $attr 1;
}

global proc xgmInitPlayblast()
{
    // Need a better way to load the UI infomation
    if( !`about -batch` ) {
        string $palettes[] = `ls -type xgmPalette`;
        if ( `size($palettes)` ) {
            python("xgui.createDescriptionEditor(False)");
        }
        python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.loadGlobals()");
    }
}

/**
 * Callback for just after a new scene command.
 */
global proc xgmAfterNewCB( string $args[] )
{
    // A new scene is started so add the expressions, even though we
    // have no xgen objects. This gets the expressions up for any
    // newly created objects.
    xgmInitPlayblast;
    if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
        python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
    }

    // delete pending folders
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().deleteAll()");
}


/**
 * Reset scene dirty flag 
 */
global proc xgmSetSceneNotDirty()
{
    file -modified false;
}


/**
 * Callback for just after a file is opened.
 */
global proc xgmAfterOpenCB( string $args[] )
{
    global int $gXgmUseHandler;
    if ( !$gXgmUseHandler ) {
        string $palettes[] = `ls -type xgmPalette`;
        if ( `size($palettes)` ) {
            xgmPostLoadImportPalettes($palettes);
        }
    }
    xgmInitPlayblast;   
    // Add the expresion in the old scene (backward compatibility)
    string $palettes[];
    catchQuiet ( $palettes = python("xg.palettes()") );
    if ( `size($palettes)` && !`objExists xgmRefreshPreview` && !`objExists xgmPreviewWarning`)
        xgmAddExpressions;

    if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
        python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
    }

    // start tracker after a scene load
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().tracking = True");

    // delete pending folders
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().deleteAll()");
    
    
    // Please read the description in xgmBeforeOpenCB about this variable
    // Reset open opeartion state flag
    global int $gIsOpeningScene;
    $gIsOpeningScene = 0;
    
    // Reset scene dirty flag after save/open a file
    // to make sure the scene is clean and no need to 
    // re-save again if user open/new another scene
    //
    xgmSetSceneNotDirty();

    // We have to use evalDeferred to do clean dirty flag again, 
    // because xgen call some scriptJob which may modify the scene.
    // These modification cannot be cleared by file IO 
    // since scriptJob is called when maya idle.
    // In other words, these modification will be left in the 
    // scene and make scene dirty.
    // 
    // "evalDeferred -lowPriority" could append the script method 
    // at the end of the idle queue. So we call xgmSetSceneNotDirty
    // by evalDeferred to reset dirty flag after other 
    // modification done.
    evalDeferred -lowPriority "xgmSetSceneNotDirty";
}

/**
 * Callback for just before a file is opened.
 */
global proc xgmBeforeOpenCB( string $args[] )
{
    // put tracker on hold during a scene load. We don't want to track newly added description when loading a scene.
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().tracking = False");

    // Set gXgenSourceFile to empty in open callback
    // because this variable is used during importing or referencing
    global string $gXgenSourceFile;
    $gXgenSourceFile = "";
    
    // When a scene file is opened, it may run reference callback if it has some
    // reference node, because it needs to create reference node and load referenced objects
    // from the file. However in this case, we do not want the callback load 
    // xgen data immediately, because the data will be loaded in open callback after
    // all nodes in the scene is referenced or loaded.
    // So we need to check if the callback is called from UI or from open operation
    // If it is from open operation, skip it.
    // Here, mark the operation state flag. 
    global int $gIsOpeningScene;
    $gIsOpeningScene = 1;
}

proc int isShaderRegistered( string $type )
{
    if (`pluginInfo -q -loaded "Mayatomr"`)
    {
        string $nodes[] = `pluginInfo -q -dependNode "Mayatomr"`;
        int $i;
        for ($i=0; $i<size($nodes); $i++)
        {
            if ($nodes[$i] == $type)
               return 1;
        }
    }
    
    return 0;
}

/**
 * Callback for just before a file is saved.
 */
global proc xgmBeforeSaveCB( string $args[] )
{
    global int $gXgmUseHandler;
    
    xgmSetVersion;
    if ( !$gXgmUseHandler ) {
        // set the palette file name before save 
        // because the file name is written in Maya scene file
        xgmSetPalettesFileName;
    }

    // bake all guides
    // if no guide exists, command "xgmBakeGuideVertices" returns failure,
    // need to catch it
    catch(`xgmBakeGuideVertices -useOrigin`);

    // clean up visualizers
    string $allViz[] = `ls -type xgmConnectivity`;
    for ( $viz in $allViz ) {
        $xform = `listRelatives -parent $viz`;
        delete $xform;
    }

    // Need a better way to save the UI infomation
    if( !`about -batch` ){
        python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.saveGlobals()");
    }
    
    if ( isShaderRegistered("xgen_geo") )
    {
        $xgenGeo = `ls -type xgen_geo`;
        for( $i = 0; $i < size($xgenGeo); $i++ ) 
        {
            updateMRShaderByGlobalMotionBlurSettings($xgenGeo[$i]);
        }
    }
    
    // update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;
}


/**
 * Callback for just after a file is saveed.
 */
global proc xgmAfterSaveCB( string $args[] )
{
    global int $gXgmUseHandler;

    if ( !$gXgmUseHandler ) {
        eval( "python( \"import xgenm.ui.xgSetMapAttr as xgsma\" )" );
        python( "xgsma.setMapAttr()" );

        xgmExportPalettes;
    }
    
    // remove all pending entries in the tracker
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().removeAll()");
    
    // Reset scene dirty flag after save/open a file
    // to make sure the scene is clean and no need to 
    // re-save again if user open/new another scene
    //
    xgmSetSceneNotDirty();

    // We have to use evalDeferred to do clean dirty flag again, 
    // because xgen call some scriptJob which may modify the scene.
    // These modification cannot be cleared by file IO 
    // since scriptJob is called when maya idle.
    // In other words, these modification will be left in the 
    // scene and make scene dirty.
    // 
    // "evalDeferred -lowPriority" could append the script method 
    // at the end of the idle queue. So we call xgmSetSceneNotDirty
    // by evalDeferred to reset dirty flag after other 
    // modification done.
    evalDeferred -lowPriority "xgmSetSceneNotDirty";
}


/**
 * Callback for just before a file is imported.
 */
global proc xgmBeforeImportCB( string $args[] )
{
    global string $gXgmPreImportPalettes[];
    $gXgmPreImportPalettes = `ls -type xgmPalette`;
    
    // The XG file may be loaded when a scene is imported
    // Since the xgen file should be in the same directory of the scene
    // and the attribute "xgFileName" only has the file base name,
    // we need to save the file path to check if the imported file and
    // the current scene are in the same directory. If the imported file
    // is not in the same directory of the current scene, we need to
    // copy the xgen file into the directory of the current scene to make the
    // current scene use it later.
    global string $gXgenSourceFile;
    $gXgenSourceFile = python("import maya.OpenMaya;maya.OpenMaya.MFileIO().beforeImportFilename()");
}


/**
 * Callback for just after a file is imported.
 */
global proc xgmAfterImportCB( string $args[] )
{
    global string $gXgmPreImportPalettes[];
    global int $gXgmUseHandler;
    if ( !$gXgmUseHandler ) {
        string $allPals[] = `ls -type xgmPalette`;
        string $palettes[]=`stringArrayRemove $gXgmPreImportPalettes $allPals`;
        if ( `size($palettes)` ) {
            if( !`about -batch` ) {
                python("if xgg.DescriptionEditor is None:\n\txg.ui.createDescriptionEditor(False)");
            }
            xgmPostLoadImportPalettes($palettes);
        }

        // Add the expresion in the old scene (backward compatibility)
        catchQuiet ( $palettes = python("xg.palettes()") );
        if ( `size($palettes)` && !`objExists xgmRefreshPreview` && !`objExists xgmPreviewWarning`)
            xgmAddExpressions;
    }

    if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
        python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
    }

    // update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;

    xgmFixNSAfterImport;
}


/**
 * Callback for just before a reference is created.
 */
global proc xgmBeforeCreateReferenceCB( string $args[] )
{
    // Please read the description in xgmBeforeOpenCB about this variable
    // Check if the callback should be skipped
    global int $gIsOpeningScene;
    if(!$gIsOpeningScene)
    {
        global string $gXgmPreImportPalettes[];
        $gXgmPreImportPalettes = `ls -type xgmPalette`;
        
        // The xgen file may be loaded when a scene is referenced
        // Since the xgen file should be in the same directory of the scene
        // and the attribute "xgFileName" only has the file base name,
        // we need to save the file path to check if the referenced file and
        // the current scene are in the same directory. If the refereced file
        // is not in the same directory of the current scene, we need to
        // copy the xgen file into the directory of the current scene to make the
        // the referenced objects and the related xgen objects in the current scene 
        // be opened correctly later.
        global string $gXgenSourceFile;
        $gXgenSourceFile = python("import maya.OpenMaya;maya.OpenMaya.MFileIO().beforeReferenceFilename()");
    }
}


/**
 * Callback for just after a reference is created.
 */
global proc xgmAfterCreateReferenceCB( string $args[] )
{
    // Please read the description in xgmBeforeOpenCB about this variable
    // Check if the callback should be skipped
    global int $gIsOpeningScene;
    if(!$gIsOpeningScene)
    {
        // Currently, the workflow of loding xgen file after importing or referencing
        // the description or collection nodes are same. So we can use the same
        // method which import callback is using.
        xgmAfterImportCB($args);
    }

    // update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;
}


/**
 * Callback for just before a reference is loaded.
 */
global proc xgmBeforeLoadReferenceCB( string $args[] )
{
    // Currently, LoadReferenceCB do same work as CreateReferenceCB
    xgmBeforeCreateReferenceCB($args);
}


/**
 * Callback for just after a reference is loaded.
 */
global proc xgmAfterLoadReferenceCB( string $args[] )
{
    // Currently, LoadReferenceCB do same work as CreateReferenceCB
    xgmAfterCreateReferenceCB($args);
}


/**
 * Callback when exiting Maya
 */
global proc xgmMayaExitingCB( string $args[] )
{
    // delete pending folders
    python("if xgg.FolderTracker.desc() is not None:\n\txgg.FolderTracker.desc().deleteAll()");
}

global proc xgmPreRendering()
{
    // Only works from within Maya. In batch this is going to crash.
    if( !`about -batch` )
    {
        // Before doing a render, export the palettes.
        // This is done to ensure renderesr that are using a different process get the updated values without having to save the scene manually.
        xgmSetPalettesFileName();
        xgmExportPalettes();

        if ( isShaderRegistered("xgen_geo") )
        {
            $xgenGeo = `ls -type xgen_geo`;
            for( $i = 0; $i < size($xgenGeo); $i++ ) 
            {
                string $data = `getAttr ($xgenGeo[$i] + ".data")`;
                string $dataList[]; 
                tokenizeList($data, $dataList);
                for( $j = 0; $j < size($dataList); $j++ ) 
                {
                    if( $dataList[$j] == "-description" )
                    {
                        string $descName = $dataList[$j+1];
                        int $objTest = `objExists $descName`;
                        if($objTest == 1)
                        {
                            xgmPushOver -d $descName;
                        }
                        break;
                    }
                }

                updateMRShaderByGlobalMotionBlurSettings($xgenGeo[$i]);
            }
        }
    }
    else
    {
        // initialize xgen global info
        python("xgg.initXGen()");
    }
}

global proc setXGenHUDSplineCountVisibility(int $displayXGenHUD)
{
    if (`headsUpDisplay -ex HUDXGenSplinesCount`)
    {
        headsUpDisplay -e -visible $displayXGenHUD HUDXGenSplinesCount;
    }
}

global proc setXGenHUDGPUMemoryVisibility(int $displayXGenHUD)
{
    if (`headsUpDisplay -ex HUDXGenGPUMemory`)
    {
        headsUpDisplay -e -visible $displayXGenHUD HUDXGenGPUMemory;
    }
}

// Grooming Tool HUD should only be shown when both XGen HUD is enabled 
// and there is active brush.
global proc setXGenHUDGroomingToolVisibility(int $displayXGenHUD)
{
    int $groomingToolHUDVisible = getXGenGroomingToolHUDVisiblity();
    int $displayGroomingToolHUD = ($displayXGenHUD && $groomingToolHUDVisible);

    if (`headsUpDisplay -ex HUDXGenGroomingTool`)
    {
        headsUpDisplay -e -visible $displayGroomingToolHUD HUDXGenGroomingTool;
    }
}

// Grooming On HUD should only be shown when XGen HUD is enabled
// and there is active brush and there is active sculpt layer (Edit is on).
global proc setXGenHUDGroomingOnVisibility(int $displayXGenHUD)
{
    int $groomingOnHUDVisible = getXGenGroomingOnHUDVisiblity();
    int $displayGroomingOnHUD = ($displayXGenHUD && $groomingOnHUDVisible);

    if (`headsUpDisplay -ex HUDXGenGroomingOn`)
    {
        headsUpDisplay -e -visible $displayGroomingOnHUD HUDXGenGroomingOn;
    }
}

global proc setXGenHUDVisibility(int $displayXGenHUD)
{
    setXGenHUDSplineCountVisibility($displayXGenHUD);
    setXGenHUDGPUMemoryVisibility($displayXGenHUD);
    setXGenHUDGroomingToolVisibility($displayXGenHUD);
    setXGenHUDGroomingOnVisibility($displayXGenHUD);
    
    if ( `menuItem -q -exists xgenDisplayHUDItem`)
    {
        menuItem -e -checkBox $displayXGenHUD xgenDisplayHUDItem;
    }
    
    if ( `menuItem -q -exists xgenInfoItem`)
    {
        menuItem -e -checkBox $displayXGenHUD xgenInfoItem;
    }
    
    optionVar -iv "xgenHUDVisibility" $displayXGenHUD;
}
